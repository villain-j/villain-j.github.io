var store = [{
        "title": "개발자의 글쓰기",
        "excerpt":"개발자의 글쓰기 후기      제목: 개발자의 글쓰기     저자: 김철수     출판사: 위키북스     출간일: 2019.10.04      목차      개발자가 알아야 할 글쓰기 기본   개발 시간을 줄여주는 이름 짓기와 주석 쓰기   사용자와 소통하는 에러 메시지 쓰기   독자 관점에서 릴리스 문서와 장애 보고서 쓰기   설명, 묘사, 논증, 서사로 개발 가이드 쓰기   수주를 돕는 SI 제안서 쓰기   기술 블로그 쉽게 쓰고 운영하기     사용하는 툴의 사용 방법을 설명하는 방법을 고민하다가 글을 너무 정리하지 못하는 것 같아서 책 표지와 제목만 보고 사서 읽은 책이다. 결론부터 말하자면 나쁘지는 않았지만 큰 도움도 되지 않았다.   독자를 고려해서 글을 쓰면 된다는 것… 모두가 알지만 여러 번 연습하기 전에는 어려운 일이다. 그리고 지금 돌이켜보면 이 책을 살 때 겪었던 어려움은 내 글의 문제도 있지만 그 이전에 내가 쓰려는 내용 자체를 내 머릿속에서 제대로 정리하지 못했던 것 같다.   대학교 때 발표 위주 강의에서 교수님이 하셨던 말씀이 생각난다. 발표할 때 대본을 다 외운다고 되는 게 아니다. 발표할 내용이 잘 정리되서 머릿속에 들어있고 그 내용에 대해 명확하게 이해한 상태라면 대본은 더 이상 의미가 없고 듣는 사람도 훨씬 명료하게 이해할 수 있다고. 이해하지 못한 상태에서 대본만 외워서 말하면 듣는 사람도 이해를 못한다고. 글쓰기도 마찬가지 아닐까. 내가 다루려는 내용이 명확하고 그에 대해서 제대로 이해도 한 상태라면 글을 쓰는 것은 웬만해서는 문제가 아니다.   이 책 독후감 결론은 내가 문제였던 걸로… ^v^;;  ","categories": ["books"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//books/Book_DeveloperWriting/",
        "teaser":null},{
        "title": "Github.io Blog 시작",
        "excerpt":"GitBlog 설정하고 이제 시작!   ","categories": ["blog"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//blog/FirstPost/",
        "teaser":null},{
        "title": "Books",
        "excerpt":"Reading List   프로그래밍           개발자의 글쓰기 김철수 / 위키북스 / 2019.10.04       졸업하고 나서 글을 써야한다는 걸 깨달았을 때 사서 읽은 책            CLR via C# (4th edition) Jefferey Richter / 비제이퍼블릭 / 2014.11.25       C#을 처음 접할 때 읽기 좋은 책. C# 버젼이 열심히 올라가는 중이라 지금과 다른 부분도 있지만 전체적으로 CLR이 무엇이고, C#이 어떻게 돌아가는지 개념을 잡는데 도움이 되었다.            C#으로 배우는 적응형 코드(Adaptive Code via C#: Agile coding with design patterns and SOLID principles) Gary McLean Hall / 제이펍 / 2015.11.26       SOLID 규칙을 접한 적이 없거나 봤지만 제대로 이해하지 못했을 때 읽으면 이해를 도와줄 책. 이 책을 읽고 대략적으로 안다고 생각했었던 객체지향에 대해 더 찾아보기 시작했다.            테스트 주도 개발(Test-Driven Development) Kent Beck / 인사이트 / 2014.02.15       TDD를 처음 접한 사람들에게 TDD를 하는 이유와 방법에 대해 잘 설명한 책이다. TDD가 모든 곳에 적용 가능하다는 말에는 아직 완전히 수긍하지는 못했지만 TDD를 통해 더 좋은 코드를 짜는 법에 대해서 배웠다.            실용주의 프로그래머(Pragmatic Programmer: from journeyman to master) Andrew Hunt, David Thomas / 인사이트 / 2007.06.20       이제 막 프로그래머로서 커리어를 시작하는 사람들을 위한 책.            오브젝트 조영호 / 위키북스 / 2019.06.17       객체지향 설계에서 유명한 책. 객체지향 설계를 하는 목표와 구체적인 방법들, 그 방법들에 대한 이유를 설명한다.            테스트 주도 개발로 배우는 객체지향 설계와 실천(Growing Object-oriented Software, guided by tests) Steve Freeman, Nat Pryce / 인사이트 / 2013.06.20       위의 TDD와 객체지향에 관한 책들을 읽으면서 이 둘을 합쳐놓은 책에도 관심이 생겼다.            클린 코드(Clean Code) Robert C. Martin / 인사이트 / 2013.12.24       혼자 과제나 프로젝트할 때에는 충분히 신경쓰지 못했지만 협업을 하면서 꼭 필요한 부분이라고 느껴져서 읽어보고 싶은 책이다.            유지보수하기 어렵게  코딩하는 방법(How to Write Unmaintanable Code) Roedy Green / 한빛미디어 / 2012.07.16       학부 때부터 인상깊은 제목때문에 궁금했던 책.            코드 컴플리트(Code Complete 2) Steve McConnell / 위키북스 / 2017.07.28       Coding horror 블로그에서 추천해서 궁금해졌다.       그 외           물만난 물고기 이찬혁 / 수카 / 2019.09.26       악동뮤지션의 이찬혁이 같은 이름의 노래를 내면서 쓴 소설. 악동뮤지션의 팬으로서 안 읽어볼 수 없었다. 우리 이 작가님(^-^)이 노래를 쓰면서 했던 생각을 엿볼 수 있는 책이다.            골든 아워: 생과 사의 경계, 중증외상센터의 기록 이국종 / 흐름출판 / 2018.10.02       알라딘 중고서점에서 발견해서 1권 초반부 읽다가 2권 다 사서 읽은 책. 읽으면서 그 상황 속에서의 사명감과 비장함, 절망과 비통함이 몹시 절절하게 느껴져서 읽으면서 많이 슬펐다. 나는 글로만 읽는데도 이런데 이를 살아내는 사람들에게 무척 존경심도 들었고, 내가 아는 세상은 매우 좁다는 것도 느꼈다. 아직 좀 덜 읽었는데 마저 읽어야지… 읽기 전에 마음의 준비가 필요하다.            보통의 언어들 김이나 / 위즈덤하우스 / 2020.05.27       작사가 김이나씨의 책은 어떨까 궁금해서 읽어보고 싶다. 예약신청 해놨는데 내 차례는 언제 오나…      ","categories": ["books"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//books/FirstPostBooks/",
        "teaser":null},{
        "title": "C Sharp",
        "excerpt":"이 카테고리에는 C#과 CLR에 대해 공부한 내용을 적을 것이다.  ","categories": ["csharp"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//csharp/FirstPostCSharp/",
        "teaser":null},{
        "title": "jekyll-archives plugin으로 Github Page 카테고리별 게시글 구성하기",
        "excerpt":"0. 삽질 이야기 + Prerequisites   예전에는 네이버 블로그에 가끔(아주 가끔…) 포스팅 했었는데 다시 꾸준히 공부하자고 결심하면서 Github Page가 더 깔끔해보여서 바꾸게 되었다. Github Page에 대해서는 이 글(Github Page 소개) 를 참고해주세요. 테마가 다양하게 제공되는데 나는 minimal-mistakes를 골랐다. 심플하기도 하고 원래 뭘 고를지 고민될 때에는 다들 많이 쓰는 쪽으로 대세에 편승하는 쪽이 속이 편하다.   Viewpoint: 블로그 생성 을 참고해서 블로그를 생성했고 여기서는 Github page에서 카테고리별 게시글을 볼 수 있는 페이지와 해당 페이지로 이어지는 메뉴바를 만드는 것을 다룰 예정이다.  이 내용만 쓰는 건 내가 여기서 헤맸기 때문… Github Page 생성하고 Jekyll 설치하고 하는 것들은 여기저기 잘 되어있는 글들이 많으니까 구글 선생님께 물어보면 될 것 같다.   카테고리별 게시글을 보여주는 페이지를 만드려면 jekyll-archives를 설치해야 한다. 그런데 Github Page는 지킬 공식 문서 에 따르면 –safe 옵션을 붙여서 페이지를 생성하기 때문에 플러그인들이 적용되지 않는다. (이걸 모르고 푸시해놓고 어… 왜 카테고리 전부 다 보여주지… 하면서 헤매고 있었다ㅠㅠ)   Prerequisites      Minimal-Mistakes Github 클론해서 Github Page 생성하기   Ruby와 Jekyll 설치하기   1. 카테고리 별 메뉴바 생성하기   Github Page 폴더에 있는 /_data/navigation.yml을 수정한다. 나의 경우에는 C# 공부, 프밍 관련 책, 지금 쓰는 jekyll-archives 같은 도구와 기타 등등 애매한 분류의 글을 넣을 Blog 4개의 카테고리를 만들었다.   main:   - title: \"About\"     url: /about/   - title: \"Category\"     url: /categories/   - title: \"Blog\"     url: /categories/blog/   - title: \"C Sharp\"     url: /categories/csharp/   - title: \"Books\"     url: /categories/books/   - title: \"Tools\"     url: /categories/tools/   메뉴를 만들었다면 이제 메뉴바의 메뉴를 눌렀을 때 보여질 페이지도 만들어야 한다.   우선 전체 카테고리의 글을 보여주는 Category에 해당하는 페이지는 아래의 /_pages/category-archive.md이다. layout을 categories로 설정해주고, 연결되는 링크인 permalink 도 그에 맞게 써준다. author_profile은 전체 _config.yml에서 설정한 author 정보를 해당 페이지에서도 보여줄 것인지를 선택하는 것이다.   --- title: \"Posts by Category\" layout: categories permalink: /categories/ author_profile: true ---   특정 카테고리만 보여주려면 taxonomy라는 항목을 추가해야 한다. 아래는 내가 만든 blog.md 파일이다. permalink는 /categories/blog와 이어주고, taxonomy는 해당 페이지에서 보여주고 싶은 카테고리 이름을 적으면 된다.   --- title: \"Personal Blog\" layout: categories permalink: /categories/blog/ author_profile: true taxonomy: blog ---   2. jekyll-archives 설치하기   jekyll-archives 는 Github Page의 글들을 날짜, 태그, 카테고리에 의해 자동으로 분류해주는 플러그인이다.   이 플러그인을 설치하기 위해서는 _config.yml과 Gemfile을 수정하고 플러그인을 다운받아 수정하면 된다.   /_config.yml 파일의 plugins 부분에서 다음과 같이 jekyll-archives를 추가한다.   # Plugins (previously gems:) plugins:   - jekyll-paginate   - jekyll-sitemap   - jekyll-gist   - jekyll-feed   - jekyll-include-cache   - jekyll-archives  # mimic GitHub Pages with --safe whitelist:   - jekyll-paginate   - jekyll-sitemap   - jekyll-gist   - jekyll-feed   - jekyll-include-cache   - jekyll-archives  Gemfile의 plugin group에도 jekyll-archives를 추가한다.   # If you have any plugins, put them here! group :jekyll_plugins do   gem \"jekyll-paginate\"   gem \"jekyll-sitemap\"   gem \"jekyll-gist\"   gem \"jekyll-feed\"   gem \"jemoji\"   gem \"jekyll-algolia\"   gem \"jekyll-include-cache\"   gem \"jekyll-archives\" end   이후 WSL bash shell에서 bundle install을 실행하면 플러그인이 설치된다.   이렇게 하면 로컬에서 돌렸을 때에는 각 페이지마다 해당 카테고리의 게시글을 볼 수 있다. Github Page에서는 아니지만….   3. 로컬에서 페이지를 빌드하고 마스터 브랜치로 푸시하기   이 부분은 방구석엔지니어: Github 블로그에서 Jekyll 플러그인 사용하기 이 분 글을 참고해서 진행했다.   간략하게만 설명하자면 master와 source branch를 만들어 기본 브랜치를 source branch로 하고, 모든 작업은 source branch에서 실행한다. 입력 후 source branch 내용을 빌드하고, Rakefile을 수정해 rake publish 명령어를 실행하면 빌드한 source branch 내용을 master branch로 자동으로 푸시할 수 있게 하는 것이다.   이렇게 카테고리 설정은 끝! 한 번 설정해 놨으니 이제 마크다운에 익숙해지고 열심히 공부하고 열심히 정리해야겠다.   Reference   devinlife: Github 블로그 메뉴 구성하기   devinlife: 블로그 카테고리와 태그 목록 구성하기   방구석엔지니어: Github 블로그에서 Jekyll 플러그인 사용하기   ","categories": ["tools"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//tools/JekyllArchives/",
        "teaser":null},{
        "title": "LeetCode Last Stone Weight",
        "excerpt":"Problem   We have a collection of stones, each stone has a positive integer weight.   Each turn, we choose the two heaviest stones and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is:      If x == y, both stones are totally destroyed;   If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.   At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)      1 &lt;= stones.length &lt;= 30   1 &lt;= stones[i] &lt;= 1000   Solution   생각 많이 안 하고 그냥 문제 그대로 풀었다. 일단 처음에 정렬해놓고 제일 큰 돌의 무게 두 개를 비교해서 같으면 둘 다 부시고 돌 개수 두 개 줄이고 다르면 더 큰 애 무게를 남겨놓고 뒤에서 앞으로 가면서 정렬된 자리에 갈 때까지 swap해줬다. 지금 풀이 쓰다가 보니까 swap할 때 for 쓰지 말고 while써서 break걸걸… 그래서 시간이 제일 잘 나오진 않았던 거겠구나. 그래도 뭐… 총 배열 길이가 30이하니까ㅎㅎㅎㅎㅎ   public class Solution {     public int LastStoneWeight(int[] stones) {         int stoneCount = stones.Length;         Array.Sort(stones);         while (stoneCount&gt;1)         {             if (stones[stoneCount-1] == stones[stoneCount-2])             {                 stones[stoneCount-1] = 0;                 stones[stoneCount-2] = 0;                 stoneCount -= 2;             }             else             {                 stones[stoneCount-2] = stones[stoneCount-1] - stones[stoneCount-2];                 stones[stoneCount-1] = 0;                 stoneCount -= 1;                 for (int i=stoneCount-1; i&gt;0; i--)                 {                     if (stones[i] &lt; stones[i-1])                     {                         int tmp = stones[i-1];                         stones[i-1] = stones[i];                         stones[i] = tmp;                     }                 }             }         }         return stones[0];     } }      흠 뭐지…? else break 추가하니까 갑자기 실행시간 90ms가 넘었다. 미스테리군…  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_LastStoneWeight/",
        "teaser":null},{
        "title": "LeetCode Middle of the Linked List",
        "excerpt":"Problem   Given a non-empty, singly linked list with head node head, return a middle node of linked list.   If there are two middle nodes, return the second middle node.   Example 1:   Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3.  (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.   Example 2:   Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one.   Note:      The number of nodes in the given list will be between 1 and 100.   Solution   /**  * Definition for singly-linked list.  * public class ListNode {  *     public int val;  *     public ListNode next;  *     public ListNode(int x) { val = x; }  * }  */ public class Solution {     public ListNode MiddleNode(ListNode head) {         int listLength = 1;         ListNode midNode = head;         ListNode node = head;         while (node.next != null)         {             listLength++;             if (listLength % 2 == 0)             {                 midNode = midNode.next;             }             node = node.next;         }         return midNode;     } }      큐ㅠㅠㅠ 이정도 위치면 더 잘 풀 수 있는 방법이 있다는 건데… 끝까지 안 가고 중간 노드가 언제인지 알 수는 없을 것 같은데 중간 과정에 낭비가 있나?  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_MiddleOfLinkedList/",
        "teaser":null},{
        "title": "LeetCode Contiguous Array",
        "excerpt":"Problem   Given a non-empty array of integers, every element appears twice except for one. Find that single one.   Note:   Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?   Example 1:   Input: [2,2,1] Output: 1   Example 2:   Input: [4,1,2,1,2] Output: 4   Solution   오… 상상도 못한 방법이었다 알고리즘 문제 열심히 풀어야지ㅠㅠ   public class Solution {     public int SingleNumber(int[] nums) {         int result = nums[0];         for (int i=1; i&lt;nums.Length; i++)         {             result = result ^ nums[i];         }         return result;     } }   ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_ContiguousArray/",
        "teaser":null},{
        "title": "LeetCode Single Number",
        "excerpt":"Problem   Given a non-empty array of integers, every element appears twice except for one. Find that single one.   Note:   Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?   Example 1:   Input: [2,2,1] Output: 1   Example 2:   Input: [4,1,2,1,2] Output: 4   Solution   오… 상상도 못한 방법이었다 알고리즘 문제 열심히 풀어야지ㅠㅠ   public class Solution {     public int SingleNumber(int[] nums) {         int result = nums[0];         for (int i=1; i&lt;nums.Length; i++)         {             result = result ^ nums[i];         }         return result;     } }     ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_SingleNumber/",
        "teaser":null},{
        "title": "LeetCode Perform String Shifts",
        "excerpt":"Problem   You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]:      direction can be 0 (for left shift) or 1 (for right shift).   amount is the amount by which string s is to be shifted.   A left shift by 1 means remove the first character of s and append it to the end.   Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.   Return the final string after all operations.   Example 1:   Input: s = \"abc\", shift = [[0,1],[1,2]] Output: \"cab\" Explanation:  [0,1] means shift to left by 1. \"abc\" -&gt; \"bca\" [1,2] means shift to right by 2. \"bca\" -&gt; \"cab\"   Example 2:   Input: s = \"abcdefg\", shift = [[1,1],[1,1],[0,2],[1,3]] Output: \"efgabcd\" Explanation:   [1,1] means shift to right by 1. \"abcdefg\" -&gt; \"gabcdef\" [1,1] means shift to right by 1. \"gabcdef\" -&gt; \"fgabcde\" [0,2] means shift to left by 2. \"fgabcde\" -&gt; \"abcdefg\" [1,3] means shift to right by 3. \"abcdefg\" -&gt; \"efgabcd\"   Constraints:      1 &lt;= s.length &lt;= 100   s only contains lower case English letters.   1 &lt;= shift.length &lt;= 100   shift[i].length == 2   0 &lt;= shift[i][0] &lt;= 1   0 &lt;= shift[i][1] &lt;= 100   Solution   첫 번째 풀이   그냥 C# System.Collections.Generic에서 제공하는 LinkedList\\&lt;char&gt;에 한 글자씩 넣고 하라는 대로 했다… 생각해보니 shift 다 합쳐서 결론적으로 몇 글자를 얼마나 옮겨야 하는지 세는 방법도 있겠구나.   public class Solution {     public string StringShift(string s, int[][] shift) {                LinkedList&lt;char&gt; str = new LinkedList&lt;char&gt;();         for (int i=0; i&lt;s.Length; i++){             str.AddLast((char)s[i]);         }         int index = 0;         while (index &lt; shift.Length)         {             if (shift[index][0] == 0)             {                 while (shift[index][1] != 0) {                     char c = str.First.Value;                     str.RemoveFirst();                     shift[index][1]--;                     str.AddLast(c);                 }             }             else             {                 while (shift[index][1] != 0) {                     char c = str.Last.Value;                     str.RemoveLast();                     str.AddFirst(c);                     shift[index][1]--;                 }             }             index++;         }                  string result = \"\";         LinkedListNode&lt;char&gt; node = str.First;         while (node != str.Last) {             result += node.Value;             node = node.Next;         }         result += node.Value;         return result;     } }      두 번째 풀이   첫 번째 풀이 쓰다가 더 나은 방법 찾아서 고침. 처음에 total을 총 길이로 나눠서 나머지를 구했어야 했는데 그 부분을 빼먹어서 Substring 인자가 마이너스가 나왔었나 그랬다. 퇴근하고 문제풀기 쉽지 않아…   public class Solution {     public string StringShift(string s, int[][] shift) {                LinkedList&lt;char&gt; str = new LinkedList&lt;char&gt;();         for (int i=0; i&lt;s.Length; i++){             str.AddLast((char)s[i]);         }                  int total = 0;         for (int i=0; i&lt;shift.Length; i++) {             if (shift[i][0] == 0) total -= shift[i][1];             else total += shift[i][1];         }         total = total % s.Length;                  if (total == 0) return s;         else if (total &lt; 0) {             // 앞에서 total 길이만큼 가져와서 뒤에 붙임             string str1 = s.Substring(-total);             string str2 = s.Substring(0, -total);             return str1+str2;         }         else {             //뒤에서 total 길이만큼 가져와서 앞에 붙임             string str1 = s.Substring(s.Length-total);             string str2 = s.Substring(0, s.Length-total);             return str1+str2;         }     } }     ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_PerformStringShift/",
        "teaser":null},{
        "title": "LeetCode Happy Number",
        "excerpt":"Problem   Write an algorithm to determine if a number n is “happy”.   A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.   Return True if n is a happy number, and False if not.   Example:   Input: 19 Output: true Explanation:  12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1   Solution   한 자리 숫자의 경우 1과 7을 제외하면 Happy Number가 될 수 있는 숫자가 없어서 한 자리 숫자일 때는 1과 7이 아니면 false를 반환한다. 한 자리 숫자가 아닌 경우 각 자리의 숫자의 제곱 합을 구해 HashSet에 넣고 이미 있으면 무한 루프를 도는 숫자이므로 false를 반환한다.   처음에 시간 효율이 너무 처참하게 나와서 몇 번 고쳤었는데 같은 코드 제출했는데도 실행 시간이 다르게 나오는 걸 보니까 음…   public class Solution {     private int GetSquareSum(int n) {         string str = n.ToString();         int result = 0;         for (int i=0; i&lt;str.Length; i++) {             int tmp = str[i]-'0';             result += tmp*tmp;         }         return result;     }          public bool IsHappy(int n) {         HashSet&lt;int&gt; sums = new HashSet&lt;int&gt;();         sums.Add(n);                  while (true) {             if (n&gt;9) {                 int result = GetSquareSum(n);                 if (sums.Contains(result)) return false;                 sums.Add(result);                 n = result;             } else {                 if (n==1 || n==7) return true;                 else return false;             }         }     } }   ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_HappyNumber/",
        "teaser":null},{
        "title": "LeetCode Maximum Subarray",
        "excerpt":"Problem   Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.   Example:   Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.   Follow up:   If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.   Solution   분명히 더 빠른 풀이랑 내 풀이랑 알고리즘 상으로는 별 차이가 없어서 왜 이렇게 시간 차이가 나지 의문이었는데 int sum, int max, int i를 다 var sum, var max, var i로 바꾸니까 빨라졌다. 무슨 차이지…? C#의 세계는 참 어렵군ㅠㅠ C# 형식을 다시 한 번 봐야 할 것 같다.   public class Solution {     public int MaxSubArray(int[] nums) {         if(nums.Length == 0) return 0;                  var sum = 0;         var max = int.MinValue;         for(var i = 0; i &lt; nums.Length; i++){             sum += nums[i];                          if(sum &gt; max) max = sum;             if(sum &lt; 0) sum = 0;         }                  return max;     } }  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_MaximumSubarray/",
        "teaser":null},{
        "title": "LeetCode Minimum Path Sum",
        "excerpt":"Problem   Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.   Note: You can only move either down or right at any point in time.   Example:   Input: [   [1,3,1],   [1,5,1],   [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Solution   그냥 간단한 DP… 아래나 오른쪽으로만 움직이면 되서 생각 많이 안 하고 간단하게 풀었다.   public class Solution {     public int MinPathSum(int[][] grid) {         int x_len = grid.Length;         int y_len = grid[0].Length;         for (int i=1; i&lt;x_len; i++) {             grid[i][0] = grid[i-1][0] + grid[i][0];         }         for (int j=1; j&lt;y_len; j++) {             grid[0][j] = grid[0][j-1] + grid[0][j];         }                  for (int i=1; i&lt;x_len; i++) {             for (int j=1; j&lt;y_len; j++) {                 grid[i][j] += grid[i-1][j]&lt;grid[i][j-1] ? grid[i-1][j] : grid[i][j-1];             }         }         return grid[x_len-1][y_len-1];     } }   ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_MinimumPathSum/",
        "teaser":null},{
        "title": "LeetCode Number Of Islands",
        "excerpt":"Problem   Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.   Example 1:   Input: 11110 11010 11000 00000  Output: 1   Example 2:   Input: 11000 11000 00100 00011  Output: 3   Solution   BFS/DFS로 풀면 된다.   public class Solution {     private bool in_range(int x_len, int y_len, int x, int y) {         return x&gt;=0 &amp;&amp; x&lt;x_len &amp;&amp; y&gt;=0 &amp;&amp; y&lt;y_len;     }          private bool bfs_search(char[][] grid, char[,] searched, int x_len, int y_len, int x, int y) {         if (searched[x,y] == '1' || grid[x][y] == '0') return false;                  searched[x,y] = '1';                  int[,] adjacent = new int[4,2] { {x-1, y}, {x+1, y}, {x, y-1}, {x, y+1} };                  for (int i=0; i&lt;4; i++) {             if (in_range(x_len, y_len, adjacent[i,0], adjacent[i,1])) {                 bfs_search(grid, searched, x_len, y_len, adjacent[i,0], adjacent[i,1]);             }         }                  return true;     }          public int NumIslands(char[][] grid) {         int x_len = grid.Length;         if (x_len == 0) return 0;         int y_len = grid[0].Length;         char[,] search_grid = new char[x_len, y_len];         for (int i=0; i&lt;x_len; i++) {             for (int j=0; j&lt;y_len; j++) {                 search_grid[i,j] = '0';             }         }                  int count = 0;         for (int i=0; i&lt;x_len; i++) {             for (int j=0; j&lt;y_len; j++) {                 if (bfs_search(grid, search_grid, x_len, y_len, i, j)) {                     count++;                 }             }         }         return count;     } }   ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_NumberOfIslands/",
        "teaser":null},{
        "title": "LeetCode Product of Array Except Self",
        "excerpt":"Problem   Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].   Example:   Input:  [1,2,3,4] Output: [24,12,8,6]   Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.   Note: Please solve it without division and in O(n).   Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)   Solution   나누기 없이 풀라니… 방법이 생각 안 나서 일단 나누기로 풀고 Solution 보고 풀었다ㅠㅠ   이거 풀었던 날 집에 와서 너무 피곤했어서 O(1) 로 푸는 방법은 적당히 보고 넘어갔었는데 지금 보니까 좀 알 것 같다.   첫 번째 풀이   left[i]는 nums[i] 왼쪽에 있는 원소들의 곱이고 right[i]는 nums[i] 오른쪽에 있는 원소들의 곱이다.   public class Solution {     public int[] ProductExceptSelf(int[] nums) {         int N = nums.Length;         int[] left = new int[N];         int[] right = new int[N];                  int product = 1;         left[0] = 1;                  for (int i=1; i&lt;N; i++) {             product *= nums[i-1];             left[i] = product;         }                  product = 1;         right[N-1] = 1;         for (int i=N-2; i&gt;=0; i--) {             product *= nums[i+1];             right[i] = product;         }                  nums[0] = right[0];         nums[N-1] = left[N-1];         for (int i=1; i&lt;N-1; i++) {             nums[i] = left[i] * right[i];         }                  return nums;     } }   두 번째 풀이   첫 번째 풀이랑 거의 비슷한데 answer[]에 기존의 left[]를 저장하고, right[]를 쓰는 대신 answer[]를 끝에서부터 채우면서 R에다가 오른쪽 원소들의 곱을 저장하면서 답을 구하면 된다.   public class Solution {     public int[] ProductExceptSelf(int[] nums) {         int N = nums.Length;         int[] answer = new int[N];                  answer[0] = 1;                  for (int i=1; i&lt;N; i++) {             answer[i] = answer[i-1] * nums[i-1];         }                  int R = 1;         for (int i=N-1; i&gt;=0; i--) {             answer[i] = answer[i] * R;             R *= nums[i];         }                  return answer;     } }   ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_ProductOfArrayExceptSelf/",
        "teaser":null},{
        "title": "LeetCode Valid Parenthesis String",
        "excerpt":"Problem   Given a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules:      Any left parenthesis '(' must have a corresponding right parenthesis ')'.   Any right parenthesis ')' must have a corresponding left parenthesis '('.   Left parenthesis '(' must go before the corresponding right parenthesis ')'.   '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.   An empty string is also valid.   Example 1:   Input: \"()\" Output: True   Example 2:   Input: \"(*)\" Output: True   Example 3:   Input: \"(*))\" Output: True   Note:      The string size will be in the range [1, 100].   Solution   여기저기서 항상 꾸준히 다시 나오는 Parenthesis 문제.   lo가 지금 열려있는 괄호의 최소 개수이고 hi가 지금 열려있는 괄호의 최대 개수이다. 지금 글자가 '('이면 열린 괄호의 최소 개수는 무조건 1개 증가하므로 lo에 1을 더하고, 아닌 경우 괄호가 닫힐 수 있으므로 lo에 1을 뺀다. 반대로 지금 글자가 ')'라면 괄호가 무조건 1개 닫히므로 hi에서 1을 뺀다. 아닌 경우에는 hi에 1을 더한다.   이렇게 했을 때 열린 괄호의 최대 개수(hi)가 음수가 되면 괄호가 이상하게 된 것이므로 false를 반환하고, 열린 괄호의 최소 개수는 음수가 될 수는 없으므로 음수인 경우 0으로 바꿔준다. 이렇게 문자열을 모두 훑었을 때 열린 괄호의 최소 개수가 0이어야 모든 괄호가 제대로 닫힌 것이다.   public class Solution {     public bool CheckValidString(string s) {         int lo = 0;         int hi = 0;         for (int i=0; i&lt;s.Length; i++) {             if (s[i]=='(') lo++;             else lo--;             if (s[i]!=')') hi++;             else hi--;             if (hi&lt;0) return lo==0;             lo = lo&gt;0 ? lo:0;         }         return lo==0;     } }  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_ValidParenthesisString/",
        "teaser":null},{
        "title": "LeetCode Construct Binary Search Tree from Preorder Traversal",
        "excerpt":"Problem   Return the root node of a binary search tree that matches the given preorder traversal.   (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)   Example 1:   Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12]   Note:      1 &lt;= preorder.length &lt;= 100   The values of preorder are distinct.   Solution   Binary Tree니까 preorder traversal 순서대로 binary tree에 그대로 넣어줘서 반환하면 된다.   /**  * Definition for a binary tree node.  * public class TreeNode {  *     public int val;  *     public TreeNode left;  *     public TreeNode right;  *     public TreeNode(int x) { val = x; }  * }  */ public class Solution {     private void InsertTreeNode(TreeNode root, int val) {         if (val &lt; root.val) {             if (root.left == null) {                 TreeNode newNode = new TreeNode(val);                 root.left = newNode;                 return;             }             else {                 InsertTreeNode(root.left, val);                 return;             }         }         else {             if (root.right == null) {                 TreeNode newNode = new TreeNode(val);                 root.right = newNode;                 return;             }             else {                 InsertTreeNode(root.right, val);                 return;             }         }     }          public TreeNode BstFromPreorder(int[] preorder) {         TreeNode root = new TreeNode(preorder[0]);         for (int i=1; i&lt;preorder.Length; i++) {             InsertTreeNode(root, preorder[i]);         }         return root;     } }   ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_ConstructBinarySearchTree/",
        "teaser":null},{
        "title": "LeetCode Search In Rotated Array",
        "excerpt":"Problem   Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.   (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).   You are given a target value to search. If found in the array return its index, otherwise return -1.   You may assume no duplicate exists in the array.   Your algorithm’s runtime complexity must be in the order of O(log n).   Example 1:   Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4   Example 2:   Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1   Solution   Binary Search 문제는 몇 번을 풀어도 한 번만에 깔끔하게 해결을 못하는 것 같다ㅠㅠ 30일 챌린지 끝나면 Binary Search 문제만 주구장창 풀어봐야지…   O(log n) 으로 해결해야 되기 때문에 우선 얼마만큼 돌아갔는지 찾는 것도 Binary search로 찾아야 한다. 그렇게 시작점을 찾고 나서 Binary Search를 한다. 나는 일단 left, right를 회전되지 않은 배열에서의 인덱스로 생각하고 (안그러면 binary search 구현하는 게 너무 생각하기 귀찮아진다…) binary search 하면서 배열에 접근할 때만 GetSkewedIndex로 회전된 배열 상의 인덱스로 바꿔서 생각했다.   public class Solution {     private int GetSkewedIndex(int index, int skewed, int size) {         index += skewed;         if (index &gt;= size) index -= size;         return index;     }          private int SkewedBinarySearch(int[] nums, int target, int left, int right, int skewed) {         if (left == right) {             int index = GetSkewedIndex(left, skewed, nums.Length);             if (nums[index] == target) return index;             else return -1;         }         else if (right-left == 1) {             int index = GetSkewedIndex(left, skewed, nums.Length);             if (nums[index] == target) return index;             index = GetSkewedIndex(right, skewed, nums.Length);             if (nums[index] == target) return index;             else return -1;         }                  int mid = GetSkewedIndex((left+right)/2, skewed, nums.Length);         if (nums[mid] == target) {             return mid;         }         else if (nums[mid] &lt; target) {             left = (left+right)/2;         }         else {             right = (left+right)/2;         }         return SkewedBinarySearch(nums, target, left, right, skewed);     }          public int Search(int[] nums, int target) {         if (nums.Length == 0) return -1;         if (nums.Length == 1) {             if (target == nums[0]) return 0;             else return -1;         }         if (nums.Length == 2) {             if (target == nums[0]) return 0;             else if (target == nums[1]) return 1;             else return -1;         }                  var left = 0;         var right = nums.Length - 1;         var mid = nums.Length / 2;         var start = -1;         // if nums[left] &gt; nums[mid], start is in left side         // else if nums[right] &lt; nums[mid], start is in right side         while (start == -1) {             if (nums[mid] &lt; nums[left]) {                 right = mid;             }             else if (nums[mid] &gt; nums[right]) {                 left = mid;             }             else start = 0;             mid = (left+right)/2;             if (left == mid) {                 if (nums[left] &gt; nums[right]) start = right;                 else start = left;             }         }                  return SkewedBinarySearch(nums, target, 0, nums.Length-1, start);     } }  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_SearchInRotatedArray/",
        "teaser":null},{
        "title": "LeetCode Leftmost Column with at least One",
        "excerpt":"Problem   (This problem is an interactive problem.)   A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order.   Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn’t exist, return -1.   You can’t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface:      BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed).   BinaryMatrix.dimensions() returns a list of 2 elements [n, m], which means the matrix is n * m.   Submissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.   For custom testing purposes you’re given the binary matrix mat as input in the following four examples. You will not have access the binary matrix directly.   Example 1:      Input: mat = [[0,0],[1,1]] Output: 0   Example 2:      Input: mat = [[0,0],[0,1]] Output: 1   Example 3:      Input: mat = [[0,0],[0,0]] Output: -1   Example 4:      Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]] Output: 1   Constraints:           1 &lt;= mat.length, mat[i].length &lt;= 100            mat[i][j] is either 0 or 1.            mat[i] is sorted in a non-decreasing way.       Solution   뭐지 블로그 들킨 거 같은 이 기분… Binary Search 문제 좀 더 풀어야지라고 쓰니까 Binary Search만 나오는 이 기분ㅋㅋㅋ   각 row에 대해 binary search를 하면서 제일 왼쪽에 있는 1을 찾는다. 찾으면서 이미 1을 찾은 줄에서 나온 column 열보다 뒷부분을 검색하는 줄은 다 스킵한다. 최대 100 x 100이므로 모든 줄을 끝까지 검사한다 해도  번을 넘지 않는다.   /**  * // This is BinaryMatrix's API interface.  * // You should not implement it, or speculate about its implementation  * class BinaryMatrix {  *     public int Get(int x, int y) {}  *     public IList&lt;int&gt; Dimensions() {}  * }  */  class Solution {     public int LeftMostColumnWithOne(BinaryMatrix binaryMatrix) {         var dimensions = binaryMatrix.Dimensions();         var maxLen = dimensions[1];         int[] left = new int[dimensions[0]];         int[] right = new int[dimensions[0]];                  for (int i=0; i&lt;dimensions[0]; ++i) {             right[i] = maxLen-1;         }                  var minRight = maxLen;         var leftmost = maxLen;         var notLeftMost = 0;                  while (notLeftMost != dimensions[0]) {             for (int i=0; i&lt;dimensions[0]; ++i) {                 // Console.WriteLine(\"Examine \" + i.ToString() + \": \" + left[i].ToString() + \", \" + right[i].ToString());                 if (left[i] == -1) continue;                                  if (left[i] &gt; minRight || left[i] &gt; leftmost || left[i]==right[i]) {                     // Console.WriteLine(\"Skip\");                     left[i] = -1;                     notLeftMost++;                     continue;                 }                                  if (left[i]+1==right[i]) {                     if (binaryMatrix.Get(i, left[i]) == 1) {                         if (leftmost &gt; left[i]) leftmost = left[i];                     }                     else if (binaryMatrix.Get(i, right[i]) == 1) {                         if (leftmost &gt; right[i]) leftmost = right[i];                     }                     left[i] = -1;                     notLeftMost++;                     continue;                 }                                  var mid = (left[i]+right[i])/2;                 if (binaryMatrix.Get(i, mid) == 0) {                     // Console.WriteLine(\"discovered 0\");                     left[i] = mid;                 }                 else {                     // Console.WriteLine(\"discovered 1\");                     right[i] = mid;                     if (mid &lt; leftmost) leftmost = mid;                     if (right[i] &lt; minRight) minRight = right[i];                 }             }             // Console.WriteLine(\"-----------------\");             // Console.WriteLine(\"leftmost: \" + leftmost.ToString() + \", skipCount: \" + notLeftMost);             // Console.WriteLine(\"-----------------\");         }                  if (leftmost == maxLen) return -1;         return leftmost;     } }  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_LeftmostColumnWithAtLeastOne/",
        "teaser":null},{
        "title": "LeetCode Subarray Sum Equals K",
        "excerpt":"Problem   Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.   Example 1:   Input:nums = [1,1,1], k = 2 Output: 2   Note:      The length of the array is in range [1, 20,000].   The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].   Solution   public class Solution {     public int SubarraySum(int[] nums, int k) {         var tot_count = 0;         var sum = 0;         Dictionary&lt;int, int&gt; map = new Dictionary&lt;int, int&gt;();         map.Add(0, 1);                  for (int i=0; i&lt;nums.Length; i++) {             sum += nums[i];             var count = 0;             if (map.TryGetValue(sum-k, out count)) {                 tot_count += count;             }             if (map.TryGetValue(sum, out count)) {                 map[sum] = count+1;             }             else {                 map.Add(sum, 1);             }         }                  return tot_count;     } }  ","categories": ["leetcode"],
        "tags": ["leetcode","csharp"],
        "url": "https://hyeyoung0112.github.io//leetcode/LeetCode_SubarraySumEqualsK/",
        "teaser":null},{
        "title": "조영호 저 Object를 읽고",
        "excerpt":"   제목: 오브젝트     저자: 조영호     출판사: 위키북스     출간일: 2019.06.17      목차   들어가며: 프로그래밍 패러다임      패러다임의 시대   프로그래밍 패러다임   1장: 객체, 설계           티켓 판매 애플리케이션 구현하기            무엇이 문제인가            설계 개선하기            객체지향 설계       2장: 객체지향 프로그래밍           영화 예매 시스템            객체지향 프로그래밍을 향해            할인 요금 구하기            상속과 다형성            추상화와 유연성       3장: 역할, 책임, 협력           협력       책임   역할   4장: 설계 품질과 트레이드오프      데이터 중심의 영화 예매 시스템   설계 트레이드오프   데이터 중심의 영화 예매 시스템의 문제점   자율적인 객체를 향해   하지만 여전히 부족하다   데이터 중심 설계의 문제점   5장: 책임 할당하기      책임 주도 설계를 향해   책임 할당을 위한 GRASP 패턴   구현을 통한 검증   책임 주도 설계의 대안   6장: 메시지와 인터페이스      협력과 메시지   인터페이스와 설계 품질   원칙의 함정   명령-쿼리 분리 원칙   7장:  객체 분해      프로시저 추상화와 데이터 추상화   프로시저 추상화와 기능 분해   모듈   데이터 추상화와 추상 데이터 타입   클래스   8장: 의존성 관리하기      의존성 이해하기   유연한 설계   9장: 유연한 설계      개방-폐쇄 원칙   생성 사용 분리   의존성 주입   의존성 역전 원칙   유연성에 대한 조언   10장: 상속과 코드 재사용      상속과 중복 코드   취약한 기반 클래스 문제   Phone 다시 살펴보기   차이에 의한 프로그래밍   11장: 합성과 유연한 설계      상속을 합성으로 변경하기   상속으로 인한 조합의 폭발적인 증가   합성 관계로 변경하기   믹스인   12장: 다형성      다형성   상속의 양면성   업캐스팅과 동적 바인딩   동적 메서드 탐색과 다형성   상속 대 위임   13장: 서브클래싱과 서브타이핑      타입   타입 계층   서브클래싱과 서브타이핑   리스코프 치환 원칙   계약에 의한 설계와 서브타이핑   14장: 일관성 있는 협력      핸드폰 과금 시스템 변경하기   설계에 일관성 부여하기   일관성 있는 기본 정책 구현하기   15장: 디자인 패턴과 프레임워크      디자인 패턴과 설계 재사용   프레임워크와 코드 재사용   마치며: 나아가기   부록A: 계약에 의한 설계      협력과 계약   계약에 의한 설계   계약에 의한 설계와 서브타이핑   부록B: 타입 계층의 구현   부록C: 동적인 협력, 정적인 코드      동적 모델과 정적 모델   도메인 모델과 구현   부록D: 참고문헌     객체 지향 프로그래밍에 대해서 내 이해가 그거 그냥 설계할 때 객체 넣는다는 거 아니야? 수준이었다는 걸 깨닫게 해 준 책이었다. 나중에 다시 볼 때를 위해 이 책을 읽으면서 깨달은 것들을 정리해보고자 한다.   객체 지향 프로그래밍은 변경에 유연하게 대처할 수 있는 코드를 작성하기 위해 책임 중심으로 객체를 만들고, 각 객체가 각자의 책임을 가지고 프로그램 실행을 위해 협력하며 자신의 역할을 하도록 설계하고 코드를 작성하는 것이다.   이 정의를 나누어서 보자면 우선 목적은 변경에 유연하게 대처할 수 있는 코드를 작성하는 것이다. 프로그램을 만들 때 처음에 완벽하고 변경이 없을 요구사항이 주어진다면 이런 고민을 하지 않아도 되겠지만 현실에서 그런 일은 없다. 요구사항은 끊임없이 변하고 추가되고 사라지므로 이에 잘 대응할 수 있어야 일을 두번 세번 열번 반복하는 일이 없게 된다. 또한 유연하게 대처하지 못하는 코드의 경우 요구사항의 변화에 따라 기존 코드도 변화해야 하고, 이 경우 찾기 힘든 버그가 생기는 경우가 잦다.      그렇다면 이를 위해 해야 할 일은 책임 중심으로 객체를 만들고, 각 객체가 각자의 책임을 가지고 프로그램 실행을 위해 협력하며 자신의 역할을 하도록 설계하고 코드를 작성하는 것이라고 한다.   왜 책임 중심으로 객체를 만들어야 하는 걸까? 책임이 중심이 되지 않으면 요구사항에 쉽게 대응하기 어렵기 때문이다. 요구사항은 결국 어떤 책임의 내용을 바꾸거나 추가하는 것이므로, 코드를 책임이 아니라 데이터 중심으로 짠다면 새로운 요구사항이 추가되었을 때 뒤엎어야 할 가능성이 높다. 이렇게 책임 위주로 설계하기 위해서는 각 객체의 역할, 책임, 협력에 대해 생각하며 설계해야 한다. 이 책에서는 그 방법으로 CRC 카드를 소개했는데, 각 객체마다 Candidate, Responsibility, Collaborator를 하나의 카드에 정리하는 것이다. Candidate은 객체가 될 수 있는 후보, Responsibility는 객체가 맡은 책임, 그리고 Collaborator는 객체와 협력하는 다른 객체이다. 이렇게 카드를 만들어 설계를 한다면 각 객체를 역할, 책임, 협력의 관점에서 설계할 수 있어 데이터 중심 설계에서 벗어나서 사고하는 데 도움이 된다.   이렇게 책임 중심으로 만들어진 객체는 프로그램을 실행하기 위해 서로 메시지를 주고받으며 협력하게 된다. 이 때 협력하는 각 객체들은 서로에 대해 너무 잘 알아서는 안된다. 이는 의존성 때문이다. 의존성을 제대로 관리하지 못할 경우, 요구사항 하나의 변경에 수많은 변경이 뒤따르게 만들 수 있다.   이제 캡슐화라는 개념이 등장할 차례이다. 기존에 내가 이해한 캡슐화는 접근 제한자 정도의 수준이었다. 외부 객체가 해당 객체의 정보를 마음대로 바꾸는 것을 막기 위해 제한을 걸어둔다는 정도? 하지만 캡슐화에서 정말 중요한 것은 변하지 않는 것만 노출하고, 변하는 것은 감추는 것이다. 인터페이스와 구현의 분리가 이를 가리킨다. 인터페이스는 다른 객체가 알고 있어야 하는 메시지이기 때문에 자주 바뀌는 내용을 메시지로 노출한다면 바뀔 때마다 그와 연관된 객체의 내용도 바꿔야 하고, 이는 변경에 유연하게 대처하는 코드와는 거리가 멀다. 그리고 많이 바꿀수록 버그는…ㅠㅠㅠ Shy code를 작성하라는 것도 같은 맥락에서 내부 구현에 대해 몰라도 인터페이스만 보고 사용할 수 있어야 하기 때문이다.   또 인상깊었던 것은 상속에 관한 내용이었다. 많은 사람들이 코드 재사용을 위해, DRY 원칙을 위해 상속을 사용해야 한다고 생각하지만 사실 상속은 그보다는 타입 계층 구현이 목적이라는 것이다. 단순히 코드 재사용을 목적으로 상속을 사용할 경우, A와 B가 같은 내용의 코드로 출발해서 점점 요구사항이 추가됨에 따라 달라질 때 이 변경을 잘 반영하기 어렵다. 따라서 상속은 Is-A 관계를 만족하고, 서브 타입이 슈퍼 타입과 같은 역할을 가질 때에만 사용하는 것이 바람직하다. 이 책에서의 예시는 펭귄과 새였다. 이 예시에서 펭귄은 새이지만, 새가 보편적으로 가지고 있는 행동인 Fly를 하지 못하는 객체이다. 이런 경우 새가 할 수 있는 행동을 펭귄은 하지 못하기에, 펭귄이 새를 상속하게 하는 것은 바람직하지 못하다.   근래 읽은 기술 관련 서적 중에서 제일 재미있고 흥미있게 읽은 것 같다! 읽으면서 새로 깨달은 부분도 많았고… 다음에 다시 읽어봐도 또 새로운 부분이 보일 것 같다. 지금까지 알고 있던 객체는 아무것도 아니었다는 걸 깨달았구… 뭔가 졸업하기 전이랑 지금이랑 실력이 크게 늘었다는 생각은 안 드는데 책 내용은 뭔가 훨씬 새롭게 와 닿았다. 왜지..?  ","categories": ["books"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//books/Object/",
        "teaser":null},{
        "title": "SynchronizationContext in C#",
        "excerpt":"   원본 출처: Parallel Computing - It’s All About the SynchronizationContext    C#을 쓰면서 처음 본 SynchronizationContext에 대해 찾아보다가 MSDN 글이 한글 버젼이 없길래… 9년 전 글이지만 번역 반 가볍게 정리해놓는 마음 반으로 쓰는 글.     SynchronizationContext는 멀티 스레딩을 조금 더 간편하게 쓸 수 있도록 .NET 프레임워크에서 제공하는 도구이다. ASP.NET, Windows Forms, Windows Presentation Foundation (WPF), Silverlight 등등 모든 .NET 프로그램에서 사용할 수 있는 유용한 도구이다.   SynchronizationContext가 필요한 이유   멀티스레딩 프로그램은 .NET 프레임워크 전부터 존재했었다. 보통 멀티스레딩 프로그램은 다른 스레드로 현재 스레드가 처리한 일을 넘기도록 구현할 필요가 있다. 기존 Windows 프로그램은 메시지 루프를 중심으로 돌아갔기 때문에 많은 프로그래들은 작업을 전달하기 위해 빌트인 큐를 사용해야 했다. Windows 메시지 큐를 쓰고 싶은 멀티스레딩 프로그램은 각자의 Windows 메시지를 커스텀하고 이를 처리하는 컨벤션을 만들어야 했다.   .NET 프레임워크가 처음으로 공개되면서, 이 패턴은 표준화되었다. 당시 .NET이 지원하는 유일한 GUI 어플리케이션은 Windows Forms이었다. 그러나 프레임워크 설계자들은 다른 모델을 대비해 보다 제네릭한 방법인 ISynchronizeInvoke라는 것을 만들었다.   ISynchronizeInvoke의 기본적인 아이디어는 source 스레드가 target 스레드에게 델리게이트를 큐잉시키고, 선택적으로 해당 델리게이트가 완료될 때까지 기다히는 것이다. 또한 현재 코드가 이미 target 스레드에서 실행되고 있는지를 확인할 수 있는 방법도 제공해 불필요하게 델리게이트가 큐잉되는 것 또한 막을 수 있었다. Windows Forms가 ISynchronizeInvoke의 구현을 제공했고, 비동기 컴포넌트를 설계하는 패턴이 만들어졌다. 모두가 행복:)   .NET 프레임워크 2.0에는 많은 변화가 있었다. ASP.NET 아키텍쳐에 비동기 페이지를 지원하기 시작한 것도 이 때이다. .NET 프레임워크 2.0전에는, 모든 ASP.NET의 요청은 각 요청이 완료될 때까지 스레드 하나가 필요했다. 이는 굉장히 비효율적이었는데, 웹 페이지 생성은 대부분 DB 쿼리와 웹 서비스 호출이 큰 부분이었기 떄문에 해당 요청을 처리하는 스레드는 각각의 오퍼레이션이 완료될 때까지 기다려야 했다. 비동기 페이지가 생긴 후로, 요청을 관리하는 스레드는 연산을 시작해놓고 다시 ASP.NET의 스레드 풀로 돌아가 쓰일 수 있게 되었다. 연산이 끝나면, 스레드 풀의 다른 스레드가 해당 요청을 완료 처리할 수 있었다.   그러나, ISynchronizeInvoke는 ASP.NET의 비동기 페이지 아키텍쳐에 적합하지 않았다. ASP.NET의 비동기 페이지는 하나의 스레드와 연관된 것이 아니었기 때문에 ISynchronizeInvoke 패턴으로 만들어진 비동기 컴포넌트들은 제대로 동작하지 않았다. 원래 스레드에 작업을 큐잉하는 방법 대신, 비동기 페이지는 페이지 요청이 완료되는지를 결정하기 위해 필요한 연산의 개수만 유지하기만 하면 됐다. 이 필요성에서 새롭게 설계된 SynchronizationContext가 ISynchronizeInvoke를 대신하게 되었다.   SynchronizationContext의 개념   ISynchronizeInvoke는 두 가지 필요를 만족했다. 하나는 동기화가 필요한지 결정하는 것이었고, 다른 하나는 한 스레드에서 다른 스레드로 작업을 큐잉하는 것이었다. SynchronizationContext는 ISynchronizeInvoke를 대체하기 위해 만들어졌지만, 설계 후 기존 ISynchronizeInvoke를 정확히 대체하지는 않게 되었다.   SynchronizationContext는 작업을 context에 큐잉할 수 있는 방법을 제공해준다. 여기서 유의할 점은 작업을 특정 스레드가 아니라 context에 큐잉한다는 것이다. 아 차이는 SynchronizationContext 구현이 대부분 하나의 특정 스레드를 기준으로 하지 않는다는 점에서 매우 중요하다. 또한 SynchronizationContext는 동기화가 필요한지를 결정하는 메커니즘을 포함하지 않는데, 이를 결정하는 것이 언제나 가능한 것은 아니었기 때문이다.   SynchronizationContext의 또 다른 특징은 각 스레드가 “current” context를 갖는다는 것이다. 각 스레드의 context는 꼭 유니크하지는 앟으며, 다른 스레드와 context 인스턴스를 공유할 수 있다. 또한 스레드가 현재 자신의 context를 바꾸는 것 또한 (드물게 쓰이지만) 가능하다.   SynchronizationContext의 세 번째 특징은 현재 진행되는 비동기 연산의 개수를 가지고 있다는 것이다. 이는 ASP.NET의 비동기 페이지나 이런 종류의 개수에 관한 정보가 필요한 다른 호스트를 사용할 수 있게 해준다. 대부분의 경우에서, 현재 SynchronizationContext가 캡쳐될 때마다 count가 늘어나고, 캡쳐된 SynchronizationContext로 context에 완료를 노티할 때마다 count가 줄어든다.   SynchronizationContext에는 다른 특징들도 많지만, 이는 대부분의 프로그래머에게 중요하지 않은 것들이다. 가장 중요한 특징들을 Figure 1에 요약해 보았다.   Figure 1 Aspects of the SynchronizationContext API   // The important aspects of the SynchronizationContext APIclass SynchronizationContext  { \t// Dispatch work to the context. \tvoid Post(..); // (asynchronously) \tvoid Send(..); // (synchronously) \t// Keep track of the number of asynchronous operations.  \tvoid OperationStarted(); \tvoid OperationCompleted(); \t// Each thread has a current context. \t// If \"Current\" is null, then the thread's current context is \t// \"new SynchronizationContext()\", by convention. \tstatic SynchronizationContext Current { get; } \tstatic void SetSynchronizationContext(SynchronizationContext); }   SynchronizationContext의 구현들   SynchronizationContext의 실제 “context”는 정확히 정의되지 않는다. 각각의 프레임워크와 호스트는 각자의 context를 정의할 수 있다. 이런 다양한 구현과 한계를 이해하면 SynchronizationContext의 개념이 무엇을 보장하고 보장하지 않는지 알 수 있다. 간략하게 구현 몇 가지를 소개하겠다.   WindowsFormsSynchronizationContext (System.Windows.Forms.dll: System.Windows.Forms)   Windows Forms 앱에서 사용하는 SynchronizationContext. UI 제어를 생성하는 스레드에서 사용된다. 여기서는 UI 제어를 위해 ISynchronizeInvoke 메서드를 사용하고, ISynchronizeInvoke 메서드는 내재된 Win32 메시지 루프에 델리게이트를 전달한다. WindowsFormsSynchronizationContext의 context는 하나의 UI 스레드이다. WindowsFormsSynchronizationContext에 큐잉된 델리게이트는 한 번에 하나씩만 특정 UI 스레드에 의해 큐잉된 순서대로 수행된다. 현재의 구현은 하나의 UI 스레드마다 하나의 WindowsFormsSynchronizationContext를 생성한다.   DispatcherSynchronizationContext (WindowsBase.dll: System.Windows.Threading)   WPF와 Silverlight 앱에서는 DispatcherSynchronizationContext를 사용한다. DispatcherSynchronizationContext는 UI 스레드의 Dispatcher에게 “보통” 수준의 우선순위로 델리게이트들을 큐잉한다. 스레드가 Dispatcher를 호출함으로써 Dispatcher loop을 시작할 때 SynchronizationContext가 설치된다. DispatcherSynchronizationContext에서의 context도 위와 마찬가지로 하나의 UI 스레드이다. 따라서 델리게이트가 수행되는 방식도 한 번에 하나씩 큐잉된 순서대로 특정 UI 스레드에 의해서 수행되는 방식으로 위와 같다. 현재 구현은 각각의 top-level window 하나당 DispatcherSynchronizationContext를 하나씩 생성한다. (같은 Dispatcher를 사용할지라도!)   Default (ThreadPool) SynchronizationContext (mscorlib.dll: System.Threading)   디폴트로 제공되는 SynchronizationContext는 default-constructed SynchronizationContext object이다. 스레드의 현재 SynchronizationContext가 null이라면, 이는 스레드가 디폴트 SynchronizationContext을 가지고 있음을 암시한다.   디폴트 SynchronizationContext는 자신의 비동기 델리게이트들을 스레드 풀에 큐잉하지만 동기적인 델리게이트는 호출 스레드에서 바로 수행한다. 따라서, 이 context는 Send를 부르는 스레드와 스레드 풀의 스레드들을 모두 커버한다. context는 Send를 호출하는 스레드를 “빌리고”, 델리게이트가 완료될 때까지 context로 가져온다. 이 관점에서 보면 기본 context는 프로세스의 아무 스레드나 다 포함할 수 있다.   스레드 풀의 스레드에는 코드가 ASP.NET에 의해 호스트되지 않는 한 디폴트 SynchronizationContext가 적용된다. 또한 Thread 클래스의 인스턴스들인 명시적인 자식 스레드에도 암시적으로 디폴트 SynchronizationContext가 적용된다. 따라서, UI 어플리케이션은 주로 두 종류의 synchronization context를 갖는다. UI SynchronizationContext는 UI 스레드에 적용되고, 디폴트 SynchronizationContext는 스레드 풀 스레드에 적용된다.   많은 이벤트 기준의 비동기 컴포넌트들은 디폴트 SynchronizationContext로는 예상대로 작동하지 않는다. 제일 널리 알려진 예시는 BackgroundWorker 하나가 다른 BackgroundWorker를 시작시키는 UI 어플리케이션에서의 오류이다. 각각의 BackgroundWorker는 RunWorkerAsync를 호출하는 스레드의 SynchronizationContext를 가져와 사용한다. 그렇게 가져온 context에서 RunWorkerCompleted 이벤트를 실행한다. 하나의 BackgroundWorker가 있을 경우, Figure 2처럼 RunWorkerAsync는 UI의 context에서 RunWorkerCompleted가 실행되게 한다.      Figure 2 A Single BackgroundWorker in a UI Context   그러나 만일 BackgroundWorker가 DoWork 핸들러에서 또 다른 BackgroundWorker를 부른다면, nested BackgroundWorker는 UI SynchronizationContext가 아닌 디폴트 SynchronizationContext를 가져오게 된다. 따라서 이 BackgroundWorker는 Figure 3 처럼 스레드 풀에서 RunWorkerCompleted를 실행하게 할 것이다.      Figure 3 Nested BackgroundWorkers in a UI Context   기본적으로 콘솔 어플리케이션과 Windows 서비스의 모든 스레드는 디폴트 SynchronizationContext 만을 가진다. 이 때문에 몇 개의 event 기준의 비동기 컴포넌트가 제대로 작동하지 않는다. 이를 해결하기 위한 한 방법은 하나의 명시적인 자식 스레드를 생성하고, 해당 스레드에 SynchronizationContext를 설치해 이 context가 문제가 되는 컴포넌트들에게 context를 제공하게 하는 것이다. 이에 관한 자세한 내용은 이 기사 대신 Nito.Async library (nitoasync.codeplex.com) 를 참고해보자! (2011년 기사인데.. 지금도 살아있으려나..?)   SynchronizationContext의 구현에 대해 참고할 것   SynchronizationContext는 다양한 프레임워크에서 작동할 수 있는 컴포넌트를 작성할 방법을 제공한다. BackgroundWorker나 WebClient가 Windows Forms, WPF, Silverlight, console, ASP.NET 어플리케이션 모두에서 작동될 수 있는 컴포넌트로 좋은 예시이다. 그러나 이처럼 재사용할 수 있는 컴포넌트를 작성하기 위해서는 기억해두어야 할 것이 있다.   일반적으로, SynchronizationContext의 구현은 동일성을 비교할 수 없다. 이는 ISynchronizeInvoke.InvokeRequired를 대체할 수 있는 것이 없다는 뜻이다. 그러나 이는 치명적인 단점은 아니다. 여러 context를 다루려고 시도하는 것보다는 이미 알고 있는 context 안에서만 실행되는 코드가 훨씬 더 깔끔하고 검증하기 쉽다.   또한 SynchronizationContext의 구현이 델리게이트 수행 순서나 델리게이트의 동기화를 무조건 보장하지는 않는다. UI 기준의 SynchronizationContext 구현은 이를 만족하지만, ASP.NET의 SynchronizationContext는 동기화만 제공한다. 디폴트 SynchronizationContext는 수행 순서와 동기화 모두 보장하지 않는다.   또한 SynchronizationContext과 스레드 간의 1대 1 관계도 성립하지 않는다. WindowsFormsSynchronizationContext는 SynchronizationContext.CreateCopy를 호출하지 않는 한 1:1 매핑이 있지만 다른 구현에서는 모두 성립하지 않는다. 따라서 어떤 context 인스턴스도 특정 스레드에서 수행될 것이라고 가정하지 않는 것이 안전하다.   마지막으로, SynchronizationContext.Post 메서드는 항상 비동기이지 않다. 대부분의 구현이 Post를 비동기로 구현하기는 하지만, AspNetSynchronizationContext가 그러지 않는 대표적인 예외이다. 이는 예상치 못한 re-entrancy 이슈를 일으킬 수 있다.   Figure 4에서 SynchronizationContext의 다양한 구현에 대한 요약을 확인할 수 있다.   Figure 4 Summary of SynchronizationContext Implementations                          Specific Thread Used to Execute Delegates       Exclusive (Delegates Execute One at a Time)       Ordered (Delegates Execute in Queue Order)       Send May Invoke Delegate Directly       Post May Invoke Delegate Directly                       Windows Forms       Yes       Yes       Yes       If called from UI thread       Never                 WPF/Silverlight       Yes       Yes       Yes       If called from UI thread       Never                 Default       No       No       No       Always       Never                 ASP.NET       No       Yes       No       Always       Always           AsyncOperationManager and AsyncOperation   .NET 프레임워크의 AsyncOperationManager와 AsyncOperation 클래스는 SynchronizationContext의 추상화를 감싸는 가벼운 wrapper이다. AsyncOperationManager는 처음으로 AsyncOperation을 생성할 때 현재의 SynchronizationContext를 가져온다. 만일 현재 SynchronizationContext가 null이라면 이를 디폴트 SynchronizationContext로 대체한다. AsyncOperation은 가져온 SynchronizationContext에 비동기적으로 델리게이트를 post한다.   대부분의 event-based 비동기 컴포넌트의 구현에서 AsyncOperationManger와 AsyncOperation을 사용한다. AsyncOperationManager와 AsyncOperation은 완료 시점이 정의된 비동기 연산에서 편리하게 쓰인다. 완료 시점이 정의됐다는 건 다른 말로는 비동기 연산이 한 시점에서 시작해 다른 시점에서 이벤트와 함께 끝난다는 것이다. 다른 비동기 알림은 완료 시점이 정의되지 않을 수도 있다. subscription과 같이 한 시점에서 시작해 완료되지 않고 계속 진행될 수 있다는 것이다. 이런 연산의 경우에는 SynchronizationContext를 바로 가져와서 직접 사용하면 된다.   새로운 컴포넌트는 더 이상 이벤트 기반의 비동기 패턴을 사용해서는 안된다. 비쥬얼 스튜디오의 비동기 Community Technology Preview (CTP) 에 task 기반의 비동기 패턴에 대한 문서가 있는데, 이는 SynchronizationContext를 통해 이벤트를 생성하는 대신 Task와 Task&lt;TResult&gt; 객체를 사용하는 방법을 다룬다. Task 기반 API가 .NET에서 비동기 프로그래밍의 미래다! :angel:   Examples of Library Support for SynchronizationContext   BackgroundWorker나 WebClient처럼 간단한 컴포넌트들은 SynchronizationContext를 밖으로 노출하지 않고 암시적으로만 사용할 수 있다. 그러다 다른 많은 라이브러리들에서는 SynchronizationContext의 사용이 더 분명히 드러난다. SynchronizationContext를 사용하는 API를 제공함으로써, 라이브러리는 프레임워크에 대해 독립적으로 변할 뿐만 아니라 숙련된 엔드 사용자에게 확장할 수 있는 포인트를 제공한다.   앞으로 논의할 라이브러리 말고도, 현재 SynchronizationContext는 ExecutionContext의 일부이다. 스레드의 ExecutionContext를 사용하는 시스템은 SynchronizationContext도 사용한다. ExecutionContext가 restore되면 SynchronizationContext 또한 restore된다.   Task Parallel Library (TPL): TaskScheduler.FromCurrentSynchronizationContext and CancellationToken.Register TPL에서는 Task 객체를 작업의 단위로 사용하고 TaskScheduler를 이용해 작업을 진행한다. 디폴트 TaskScheduler는 디폴트 SynchronizationContext처럼 스레드 풀에 task를 큐잉한다. TPL queue가 제공하는 또 다른 TaskScheduler는 SynchronizationContext에 task를 큐잉한다. UI 업데이트는 Figure 5 에서처럼 nested task에서 수행될 수 있다.   Figure 5 Progress Reporting with UI Updates   private void button1_Click(object sender, EventArgs e) {   // This TaskScheduler captures SynchronizationContext.Current.   TaskScheduler taskScheduler = TaskScheduler.FromCurrentSynchronizationContext();   // Start a new task (this uses the default TaskScheduler,    // so it will run on a ThreadPool thread).   Task.Factory.StartNew(() =&gt;   {     // We are running on a ThreadPool thread here. \t// Do some work. \t// Report progress to the UI.     Task reportProgressTask = Task.Factory.StartNew(() =&gt;       {         // We are running on the UI thread here.         ; // Update the UI with our progress.       },       CancellationToken.None,       TaskCreationOptions.None,       taskScheduler);     reportProgressTask.Wait(); \t \t// Do more work.   }); }   CancellationToken 클래스는 .NET 프레임워크 4.0에서 여러 종류의 취소를 할 때 쓰인다. 기존의 취소 방식과 통합하기 위해서, 이 클래스는 취소가 요청되었을 때 델리게이트를 실행할 수 있도록 한다.델리게이트가 등록되면, SynchronizationContext가 전달될 수 있다. 취소가 요청되면, CancellationToken은 직접 델리게이트를 실행하는 대신 SynchronizationContext에 델리게이트를 큐잉한다.   ​   Limitations and Guarantees   이 문단 문장을 요약하면 뭐든 알아두면 좋다 ^-ㅠ 크로스 프레임워크 컴포넌트나 라이브러리에서 사용하는 SynchronizationContext가 뭘 할 수 있고 뭘 하지 못하는지 이해하면 관련 코드를 써먹기 좋으니까! 그리고 뭐든… 모르는 상태에서 그래서 이게 도대체 뭔데?! :angry: 하는 것보다 뭔지 대강 알아놓으면 마주쳤을 때 아 나 얘 알아! 하고 이해하는 과정이 좀 더 즐거우니까.     Stephen Cleary has had an interest in multithreading ever since he first heard of the concept. He’s completed many business-critical multitasking systems for major clients including Syracuse News, R. R. Donnelley and BlueScope Steel. He regularly speaks at .NET user groups, BarCamps and Day of .NET events near his home in Northern Michigan, usually on a multithreading topic. He maintains a programming blog at nitoprograms.com.   Thanks to the following technical expert for reviewing this article: Eric Eilebrecht  ","categories": ["csharp"],
        "tags": ["CSharp","AsyncProgramming","SynchronizationContext"],
        "url": "https://hyeyoung0112.github.io//csharp/SynchronizationContext/",
        "teaser":null},{
        "title": "CLR의 실행 모델",
        "excerpt":"        Compiling Source Code into Managed Module       CLR: Common Language Runtime, 공용 언어 런타임       CLR은 메모리 관리, 어셈블리 로딩, 보안, 예외처리, 쓰레드 동기화 등등을 관리한다.       서로 다른 언어들이 사용할 수 있는 런타임 환경을 가리킨다. 각각의 언어를 CLR을 타깃으로 하는 컴파일러로 컴파일하면 managed module(PE32/PE32+)이 된다.       Managed module에는              PE32/PE32+ header: file type(dll, gui, cui…)       CLR header: CLR 모듈이 되게 만드는 정보를 가짐       metadata: types, members, etc       IL code: 컴파일러가 생성한 코드. 실행될 때 native CPU 명령어로 변환되어 실행된다.           등의 내용이 있다.            Combining Managed Module to Assemblies       Assembly: .NET 기반 어플리케이션에서의 기본 단위: 재사용, 보안, 버젼 제어 등에서의 기본 단위이다.       1개 혹은 그 이상의 리소스 파일이 조합된 결과이다. “manifest”라는 metadata table을 가진다.       .dll, .exe 파일 등의 형태로 존재한다.            Loading the CLR       .NET 설치 필요       Platform switch: 결과 모듈 설정 가능(CPU, 32/64 bit)            Executing Your Assembly’s Code       IL: CPU에 독립적인 기계어. 객체지향적인 기계어.       메서드가 처음 불리면 JIT(Just In Time) 컴파일러가 해당 IL 코드를 native CPU instruction으로 변환하고, 이를 동적 메모리에 저장한다. (어플리케이션이 종료되면 날라감) 그 다음에 또 실행되면 바로 dynamic memory에 저장된 부분으로 이동해서 실행된다.       생각보다 IL 코드 변환 / 동적 메모리 오버헤드로 인한 성능 저하가 크지 않고, 로컬 플랫폼에 최적화되게 코드를 생성하기 때문에 효율적이다.            IL &amp; Verification       IL은 스택을 기반으로 하고 타입이 정해져있지 않다. 이 때문에 verification을 통해 코드의 안전성을 테스트하고, verification이 보안을 보장한다. 이 때문에 같은 주소 공간에 여러 프로세스를 돌려도 안전하다.       verification을 사용하지 않는 코드도 사용할 수는 있지만 위험하므로 시스템이 허용할 경우에만 실행 가능하다.            The Native Code Generator Tool : NGen.exe       어플리케이션이 설치될 때 native code로 컴파일하게 하는 툴이다. 이를 통해 프로그램을 시작할 때 걸리는 시간이 감소하고, 여러 프로그램에서 공유할 수 있기 때문에 메모리 사용량이 감소한다. 그러나 코드가 유출될 가능성이 있고, 현재 로컬 환경과 설치될 때의 환경이 달라 생길 수 있는 문제, 실행 시간이 증가하는 문제 또한 안고 있다.            The Framework Class Library(FCL)       .NET 프레임워크에서 시스템 기능을 사용할 수 있도록 제공하는 라이브러리.       유틸리티 기능, 운영체제 기능 wrapper, 프레임워크를 위한 FCL들이 존재한다.       System, System.Collections, System.IO, System,Linq 등등 없어서는 안 될 소중한 라이브러리들!            Common Type System(CTS)       CLR에서 다른 언어로 쓰인 코드와 상호작용할 수 있도록 공통적인 Type을 정의하고 사용 방법을 설명하기 위한 공식 규약이다.       Type의 종류에는 Class, Structure, Enum, Interface, Delegate가 있다.            Common Language Specification(CLS)       여러 언어가 공통적으로 가지고 있어 사용할 수 있는 부분을 정의한다. CTS의 부분 집합으로, CTS에서의 규칙은 모두 CLS에 적용된다.            Interoperability with Unmanaged Code       Managed 환경에서는 dll 파일 안의 unmanaged 코드를 호출할 수 있다.       Managed 환경에서는 COM component를 호출할 수 있다.       Unmanaged 환경에서도 managed type을 사용할 수 있다.      ","categories": ["csharp"],
        "tags": [],
        "url": "https://hyeyoung0112.github.io//csharp/CLR/",
        "teaser":null}]
