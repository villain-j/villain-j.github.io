---
title: "조영호 저 Object를 읽고"
categories:
  - books
author_profile: true
read_time: true

classes: wide
toc: false
---



> 제목: 오브젝트
>
> 저자: 조영호
>
> 출판사: 위키북스
>
> 출간일: 2019.06.17

------

<details>

### 목차

**들어가며: 프로그래밍 패러다임**

1. 패러다임의 시대
2. 프로그래밍 패러다임

**1장: 객체, 설계**

1. 티켓 판매 애플리케이션 구현하기

2. 무엇이 문제인가

3. 설계 개선하기

4. 객체지향 설계

**2장: 객체지향 프로그래밍**

1. 영화 예매 시스템

2. 객체지향 프로그래밍을 향해

3. 할인 요금 구하기

4. 상속과 다형성

5. 추상화와 유연성

**3장: 역할, 책임, 협력**

1. 협력

2. 책임
3. 역할

**4장: 설계 품질과 트레이드오프**

1. 데이터 중심의 영화 예매 시스템
2. 설계 트레이드오프
3. 데이터 중심의 영화 예매 시스템의 문제점
4. 자율적인 객체를 향해
5. 하지만 여전히 부족하다
6. 데이터 중심 설계의 문제점

**5장: 책임 할당하기**

1. 책임 주도 설계를 향해
2. 책임 할당을 위한 GRASP 패턴
3. 구현을 통한 검증
4. 책임 주도 설계의 대안

**6장: 메시지와 인터페이스**

1. 협력과 메시지
2. 인터페이스와 설계 품질
3. 원칙의 함정
4. 명령-쿼리 분리 원칙

**7장:  객체 분해**

1. 프로시저 추상화와 데이터 추상화
2. 프로시저 추상화와 기능 분해
3. 모듈
4. 데이터 추상화와 추상 데이터 타입
5. 클래스

**8장: 의존성 관리하기**

1. 의존성 이해하기
2. 유연한 설계

**9장: 유연한 설계**

1. 개방-폐쇄 원칙
2. 생성 사용 분리
3. 의존성 주입
4. 의존성 역전 원칙
5. 유연성에 대한 조언

**10장: 상속과 코드 재사용**

1. 상속과 중복 코드
2. 취약한 기반 클래스 문제
3. Phone 다시 살펴보기
4. 차이에 의한 프로그래밍

**11장: 합성과 유연한 설계**

1. 상속을 합성으로 변경하기
2. 상속으로 인한 조합의 폭발적인 증가
3. 합성 관계로 변경하기
4. 믹스인

**12장: 다형성**

1. 다형성
2. 상속의 양면성
3. 업캐스팅과 동적 바인딩
4. 동적 메서드 탐색과 다형성
5. 상속 대 위임

**13장: 서브클래싱과 서브타이핑**

1. 타입
2. 타입 계층
3. 서브클래싱과 서브타이핑
4. 리스코프 치환 원칙
5. 계약에 의한 설계와 서브타이핑

**14장: 일관성 있는 협력**

1. 핸드폰 과금 시스템 변경하기
2. 설계에 일관성 부여하기
3. 일관성 있는 기본 정책 구현하기

**15장: 디자인 패턴과 프레임워크**

1. 디자인 패턴과 설계 재사용
2. 프레임워크와 코드 재사용

**마치며: 나아가기**

**부록A: 계약에 의한 설계**

1. 협력과 계약
2. 계약에 의한 설계
3. 계약에 의한 설계와 서브타이핑

**부록B: 타입 계층의 구현**

**부록C: 동적인 협력, 정적인 코드**

1. 동적 모델과 정적 모델
2. 도메인 모델과 구현

**부록D: 참고문헌**

------



객체 지향 프로그래밍에 대해서 내 이해가 그거 그냥 설계할 때 객체 넣는다는 거 아니야? 수준이었다는 걸 깨닫게 해 준 책이었다. 나중에 다시 볼 때를 위해 이 책을 읽으면서 깨달은 것들을 정리해보고자 한다.



객체 지향 프로그래밍은 변경에 유연하게 대처할 수 있는 코드를 작성하기 위해 책임 중심으로 객체를 만들고, 각 객체가 각자의 책임을 가지고 프로그램 실행을 위해 협력하며 자신의 역할을 하도록 설계하고 코드를 작성하는 것이다.

이 정의를 나누어서 보자면 우선 목적은 변경에 유연하게 대처할 수 있는 코드를 작성하는 것이다. 프로그램을 만들 때 처음에 완벽하고 변경이 없을 요구사항이 주어진다면 이런 고민을 하지 않아도 되겠지만 현실에서 그런 일은 없다. 요구사항은 끊임없이 변하고 추가되고 사라지므로 이에 잘 대응할 수 있어야 일을 두번 세번 열번 반복하는 일이 없게 된다. 또한 유연하게 대처하지 못하는 코드의 경우 요구사항의 변화에 따라 기존 코드도 변화해야 하고, 이 경우 찾기 힘든 버그가 생기는 경우가 잦다.

<Best code is working code 짤 넣어야지>

그렇다면 이를 위해 해야 할 일은 책임 중심으로 객체를 만들고, 각 객체가 각자의 책임을 가지고 프로그램 실행을 위해 협력하며 자신의 역할을 하도록 설계하고 코드를 작성하는 것이라고 한다.

왜 책임 중심으로 객체를 만들어야 하는 걸까? 책임이 중심이 되지 않으면 요구사항에 쉽게 대응하기 어렵기 때문이다. 요구사항은 결국 어떤 책임의 내용을 바꾸거나 추가하는 것이므로, 코드를 책임이 아니라 데이터 중심으로 짠다면 새로운 요구사항이 추가되었을 때 뒤엎어야 할 가능성이 높다.

이렇게 책임 중심으로 만들어진 객체는 프로그램을 실행하기 위해 서로 메시지를 주고받으며 협력하게 된다. 이 때 협력하는 각 객체들은 서로에 대해 너무 잘 알아서는 안된다. 이제 캡슐화라는 개념이 등장할 차례이다. 기존에 내가 이해한 캡슐화는 접근 제한자 정도의 수준이었다. 외부 객체가 해당 객체의 정보를 마음대로 바꾸는 것을 막기 위해 제한을 걸어둔다는 정도? 하지만 캡슐화에서 정말 중요한 것은 변하지 않는 것만 노출하고, 변하는 것은 감추는 것이다. 인터페이스와 구현의 분리가 이를 가리킨다.